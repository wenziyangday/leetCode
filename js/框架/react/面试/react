1.循环中、条件或者嵌套函数中调用hooks ？
  如果使用了，就会报错，React 会抛出error
  这与React Hooks的底层设计的数据结构相关，react 用链表来严格保证hooks的顺序

2.react 事件委托

3.react Router 有几种模式，以及实现原理
  hash
  history模式：

4.函数组件和类组件的区别
  类组件：
    无论是使用函数或是类来声明一个组件，他绝不能修改自身的props
      所有react组件都必须是纯函数，并禁止修改自身props
    react是单项数据流，父组件改变了属性，那么子组件视图会更新
      属性的props是外界传递过来的，状态state是组件本身的，状态可以在组件中任意修改
      组件的属性和状态改变都会更新视图
  函数组件：
    函数组件接收一个单一的props对象并返回一个react元素

  区别：
    语法上
      两者最明显的不同就是在语法上，函数组件是一个纯函数，它接收一个props对象返回一个react元素。而类组件需要去继承React.component 并且创建render函数
      返回react元素，这将会要更多的代码，虽然他们实现的效果相同
    状态管理
      因为函数组件是一个纯函数，你不能在组件中使用setState,这也是为什么把函数组件称作为无状态组件
      如果你需要在你的组件中使用state，你可以选择创建一个类组件，或者将state提升到你的父组件，然后通过props对象传递到子组件
    生命周期钩子
      你不能在函数组件中使用生命周期钩子，原因和不能使用state一样，所有的生命周期钩子都是来自于继承的react.Component 中
      因此你要是想使用生命周期钩子函数，必须要使用类组件
    调用方式
      函数组件重新渲染将重新调用组件方法返回新的react元素，类组件重新渲染将new一个新的组件实例，然后调用render类方法返回react元素，这也说明为什么类组件中的this是可变的

5.高阶组件
  高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件。
  基本上，这是从react的组成性质派生的一种模式，我们称他们为纯组件，因为他们可以接收任何动态提供的子组件，但他们不会修改或复制其输入组件的任何行为

  高阶组件（HOC）是react中用于复用组件逻辑的一种高级技巧
  高阶组件的参数为一个组件返回一个新的组件
  组件是将props转换为ui，而高阶组件是将组件转换为另一个组件

6.constructor中super与props参数一起使用的目的是什么
  在调用方法之前，子类构造函数无法使用this引用super()
  在es6中，在子类的constructor中必须先调用super才能引用this，
  在constructor中可以使用this.props

7.受控组件
  非受控组件（无状态组件）：组件的状态不受React控制的组件
  受控组件（有状态组件）：就是组件的状态受react控制。

8.jsx
  JavaScript in xml
  一种在react组件内部构建标签的类xml语法。
  jsx为react.js 开发的一套语法糖，也是react的使用基础
  react在不适用jsx的情况下一样可以工作，然而使用jsx可以提高组件的可读性，因此推荐使用jsx

  有点：
    允许使用熟悉的语法来定义html元素树
    提供更加语义化且移动的标签
    程序结构更容易被直观化
    抽象了react element的创建过程
    可以随时掌控html标签以及生成这些标签的代码
    是原生的JavaScript

9.React.PureComponent 和 React.Component 有什么区别
  区别：
    component需要手动实现shouldComponentUpdate,
    而PureComponent 通过浅比较默认实现shouldComponentUpdate 方法

    浅比较只比较第一层，复杂的数据结构可能会导致更新问题

    pureComponent 不仅会影响本身，而且会影响子组件，所以PureComponent 最佳情况是展示组件

10.react？
  react是一个简单的JavaScript UI库，用于构建高效、快速的用户界面
  它使用虚拟dom来有效的操作dom
  它遵循从高阶组件到低阶组件的单向数据流

11.react 中如何使用样式
  外部样式表
  内联样式
  定义样式对象并使用它

12.为什么不能直接修改state
  react中不能直接修改state，组件不会重新渲染
  而是通过setState 方法，状态改变时，组件通过重新渲染做出响应
  setState通过一个队列机制来实现state更新。当执行setState的时候，将会需要更新的state合并后放入状态队列，而不会立刻更新this.state.
  队列机制可以高效的批量更新state，如果不通过setState 而直接修改this.state,那么该state将不会被放入状态队列中，当下次调用setState并对状态队列进行合并是，
  将会忽略之前被直接修改的state，而造成无法预知的错误

13.React 中如果绑定事件使用匿名函数有什么影响？
  在react的组件生命周期中会根据props是否发生变化确定是否对组件进行更新
  而在使用匿名函数时，组件每次都会认为是一个新的props，不会使用缓存优化，在性能上会有一定的损耗

14.react的事件代理机制和原生事件绑定混用会有什么问题
  平时使用应尽量避免
  react的合成事件层，并没有将事件直接绑定到dom元素上，所以使用e.stopPropagation() 来阻止原生dom的冒泡行为是不行的，阻止react事件冒泡行为只能用于react
  合成事件系统，但是，在原生事件中的阻止冒泡行为，却可以阻止react合成事件的传播

15.react 合成事件机制/代理机制
  react基于浏览器的事件机制自身实现了一套事件机制，包括事件注册、事件的合成、事件的冒泡、事件派发等，在react中这套事件机制称之为合成事件

  与原生事件直接在元素上注册的方式不同的是，

  react 的合成事件不会直接绑定到目标dom节点上，用事件委托机制，以队列的方式，从触发事件的组件向父组件进行回溯，直到root 节点
  因此 react组件上声明的事件最终绑定到root对象上，在root上，用一个统一的监听器去监听，这个监听器上保存这个目标节点和事件对象的映射，
  当组件挂载或者卸载时，只需要在这个同一的事件监听器上插入或者删除对应对象，当事件发生时，在哪个赢设立按照冒泡或捕获的路径去组件中手机真正的事件处理函数，然后再由这个同一的事件监听器对所
  收集的事件逐一执行

  原生事件：
    事件捕获-事件目标-事件冒泡

  合成事件和原生事件的区别
    事件名称命名方式不同
      原生全部小写，react是 驼峰
    事件处理函数的写法不同
      原生事件中事件处理函数为字符串
      react jsx，传入一个函数作为事件的处理函数
    阻止默认行为的方式不同
      原生事件中可以通过return false 来阻止默认行为
      而react中使用的则是e.preventDefault()

  react 合成事件和原生事件执行顺序
    react 所有事件都委托在root对象上，
    当真实dom元素触发事件会冒泡到root对象后，在处理react事件
    在捕获阶段，先注册的事件先执行，且react合成事件先于原生事件执行，冒泡阶段，先注册的后执行，且原生事件先于react事件执行

  阻止冒泡：
    原生事件冒泡：
      e.stopPropagation() 或者 e.cancelBubble = true

16.react 的事件代理机制和原生事件绑定的区别
  a.事件传播与阻止事件的传播：
    react的合成事件并没有实现事件的捕获只支持了事件冒泡，阻止事件传播 React 做了兼容性处理，
    只需要e.preventDefault()即可，原生存在兼容性问题

  b.事件类型：
    react是原生事件类型的一个子集，有一部分事件并没有实现（如 window的resize事件）

  c.事件绑定方式
    原生事件系统中支持多种不同的绑定事件的方式，React只有一种

  d.事件对象;
    原生中存在IE的兼容性问题，react做了兼容处理

17.React 中why 要给组件key
  在开发过程中，我们需要保证某个元素的key在其同级元素中具有唯一性
  在react diff 算法中，react会借助元素的key值来判断元素是新创建的韩式被移动而来的元素，从而减少不必要元素的重新渲染
  此外，react 还需要借助key值来判断元素与本地状态的关联关系

18.setState 是同步还是异步的？
  setState只有在合成事件和hook中是异步的，
    无论调用多少次setState，都不会立即执行更新，而是将要更新的存入_pendingStateQueue,将要更新的数组存入dirtyComponent
    当上一次更新机制执行完毕，以生命周期为例，所有组件，即最顶层组件didmount 后会将此批处理标志设置为false，这是将去除dirtyComponent中的组件以及
    _pendingStateQueue中的state进行更新，这样就可以确保组件不会被重新渲染多次
    setState本是不是异步的，而是react的批处理机制会给人一种异步的假象

  在原生事件和setTimeout中是同步的

19.react 把真是的dom树转换为js对象树，也就是virtual DOM。
  每次数据更新后，重新计算vm，并和上一次生成的vm树进行对比，对发生变化的部分进行批量更新，除了性能之外，vm的实现最大的好处在于和其他平台的集成

20.为啥react的vm可以提高性能
  因为vm并不是真实的操作dom，通过diff算法可以避免一些不必要的dom操作，从而提高了性能

21.react hooks 带来的便利
  在没有hooks之前，我们使用函数定义的组件中，不能使用react的state、各种生命周期钩子类组件的特性，在react16.8之后，推出了新功能，hooks，通过hooks
  我们可以在函数定义的组件中使用类组件的特性

  好处：
    跨组件复用：
      其实render props / HOC 也是为了复用，相比于他们，hooks作为官方的底层api，最为轻量，而且改造成本低，不会影响原来的组件层次结构和嵌套地狱问题
    相比较，类组件的实现更为复杂
      不同的生命周期会使逻辑变得分散且混乱，不易维护和管理
      要时刻关注this的指向问题
      代码复用代价大，高阶组件的使用会使整个组件树变得臃肿
    状态和UI隔离，这样我们可以将状态逻辑变得粒度更小，并且很容易被抽象成一个自定义的hooks，组件中的状态和ui变得更为清晰和隔离

22.router中的<Link> 和 a 的区别
  link避免了不必要的重新渲染，
  link：
    有onclick执行onclick
    click的时候会阻止a的默认事件
    根据href跳转，用history跳转，此时只是链接变了，并没有刷新页面

23.react diff
  原则：
    DOM节点的跨层级移动特别的少，可以忽略不计
    拥有相同类的两个组件将会生成相似的树形结构，
    对于同一层级的一组子节点，可以通过唯一的id进行区分

  tree diff
    dom 跨级操作比较少，diff 算法只会对同级的dom进行比较，如果发现节点不存在，那么会将该节点以及其子节点完全删除，不会在进行比较。
    如果出现跨级移动，那么会删除该节点及其子节点，然后在移动后的位置重新创建

  component diff
    若果是同一类型的组件，那么会继续对别vm数
    同一类型的组件，有可能vm没有任何变化，所以用户通过设置shouldComponentUpdate() 来判断是否需要进行diff算法

    不同一类型，那么会将其自子节点完全替换，不会在进行比对

  element diff
    当节点处于同一级时，有三种操作，插入、移动、删除
    对于同一层级的同组子节点，添加唯一的key进行区分，这样就可以判断出来是否是移动节点
    通过key返现新旧集合中的节点都是相同的节点，就只需要进行移动操作就可以

24.React Hooks当中的useEffect是如何区分生命周期钩子的
  useEffect可以看成是 componentDidMount，componentDidUpdate 和 componentWillUnmount 三者的结合。
  componentDidMount [] 依赖中无值
  componentDidUpdate [] 添加依赖项
  componentWillUnmount 通过return () => {} 销毁/卸载组件

25.数组下表作为key
  diff 算法 是使用key 作为同级比较的
  使用下标：
    在数组头部或者尾部插入或者删除元素：
      所有的key都会变化，进而重新渲染，造成性能损耗
    而如果使用数组中唯一值来作为key：
      不管在何处插入或者删除节点，其他key对应的节点的值未发生改变

26.fiber 是react内部所定义的一种数据结构，
  他是fiber树结构的节点单位

  Fiber 用于描述时间片的数据结构

  Fiber是通过分片来解决JavaScript中同步操作时间片过程的问题（由于JavaScript是单线程的原因，每个同步任务不能耗时太长，否则就会引起页面渲染堵塞）
  将同步过程中时间片过长的，进行拆分多个时间片，从而可以释放线程独占权，让其他任务也能得到运行的机会

  React Fiber 把更新过程碎片化，每执行完一段更新过程，就会把控制权交给react负责任务协调的模块，优先更新紧急任务，





