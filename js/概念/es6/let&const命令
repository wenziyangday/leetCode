1.let
  用来声明变量。用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。

  变量提升：var
  暂时性死区：
    ES6规定，如果在代码块中存在let 或者const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。
    凡是在声明之前使用这些变量，就会报错（ReferenceError）

  不允许重复声明：
    相同作用域内，不能重复声明同一个变量

  块级作用域：
    ES5只有全局作用域和函数作用域，没有块级作用域

    场景：
      内层变量覆盖外层变量
      用来计数的循环变量泄露为全局变量

  ES6的块级作用域：
    let实际上为JavaScript新增了块级作用域
    ES6的块级作用域允许任意嵌套

    外层作用域不可以读取内层作用域中的变量
    内层作用域可以定义外层作用域的同名变量。

  ES5规定，函数只能在顶层作用域和函数作用域内声明，不能在块级作用域中生成。但是实际运行中，能够运行不会报错。

  const 命令：
    const 声明一个 只读的常量。一旦声明，常量的值就不能改变了。
    本质：
      const 实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。
      对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。
      对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，
      const只能保证指针是固定的（即总是指向另一个固定的地址）


  对象解构：
    对象的结构赋值的内部机制，是先找到同名属性，然后再赋值给对应的变量。¬

