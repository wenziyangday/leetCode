1.let
  用来声明变量。用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。

  变量提升：var
  暂时性死区：
    ES6规定，如果在代码块中存在let 或者const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。
    凡是在声明之前使用这些变量，就会报错（ReferenceError）

  不允许重复声明：
    相同作用域内，不能重复声明同一个变量

  块级作用域：
    ES5只有全局作用域和函数作用域，没有块级作用域

    场景：
      内层变量覆盖外层变量
      用来计数的循环变量泄露为全局变量

  ES6的块级作用域：
    let实际上为JavaScript新增了块级作用域
    ES6的块级作用域允许任意嵌套

    外层作用域不可以读取内层作用域中的变量
    内层作用域可以定义外层作用域的同名变量。

  ES5规定，函数只能在顶层作用域和函数作用域内声明，不能在块级作用域中生成。但是实际运行中，能够运行不会报错。

  const 命令：
    const 声明一个 只读的常量。一旦声明，常量的值就不能改变了。
    本质：
      const 实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。
      对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。
      对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，
      const只能保证指针是固定的（即总是指向另一个固定的地址）

      对于复合类型的 const 进行局部修改不会报错，但是全局修改会发生错误

  readonly 命令：
    只读属性
    readonly 修饰的对象属性是不可以进行单独修改的，但是对象重新赋值是可以的

  Readonly<T> 修饰的变量是不能进行局部修改，但是对象重新赋值（全局替换）是可以的
  (ReadonlyArray<T> 或者 readonly number[]) 修饰的变量是不能进行局部修改，但是对象重新赋值（全局替换）是可以的
  类型推导 let aa = [1, 2, 3, 4, 5] as const; 是不能进行局部修改 以及全局修改的


  对象解构：
    对象的结构赋值的内部机制，是先找到同名属性，然后再赋值给对应的变量。¬

    用途：
      交换变量的值 [a, b] = [b, a]
      从函数返回多个值 let {a, b, ...rest} = function() {}
      函数参数的解构使用 function([a, b])
      提取JSON数据 {a, b} = {a: 1, b: 10, c: 100}
      设置函数参数的默认值，从而避免变量的判空处理 function({a = 1, b = 2}) {}
      遍历Map 解构
      输入模块的指定方法 import {useState, useCallback} from 'react'; const {} = require('')

