扩展运算符（...）的应用：
  复制数组
  合并数组
  与结构赋值相结合 [aa, ...rest]
  字符串
  实现了Iterator接口对象
    任何定义了遍历器（Iterator）接口的对象（扩展运算符内部调用的是数据结构的 Iterator 接口）(遍历器接口（Symbol.iterator）)，
      都可以用扩展运算符转为真正的数组。
    对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组.
  Map 和 Set 结构，Generator 函数
    Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符

  tips:
    如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错。

  Array.from() :
    Array.from方法用于将两类对象转为真正的数组：
      类似数组的对象（array-like object）
        Array.from方法还支持类似数组的对象。
        所谓类似数组的对象，本质特征只有一点，即必须有length属性。
      可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）
    Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组
    Array.from()可以将各种值转为真正的数组，并且还提供map功能
      这实际上意味着，只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法
    Array.from的第一个参数指定了第二个参数运行的次数。这种特性可以让该方法的用法变得非常灵活
    Array.from()的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种 Unicode 字符，可以避免 JavaScript 将大于\uFFFF的 Unicode 字符，算作两个字符的 bug。

    区别：
      任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换

    Array.of()：
      Array.of()方法用于将一组值，转换为数组
      这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异
      Array()方法没有参数、一个参数、三个参数时，返回的结果都不一样。
      只有当参数个数不少于 2 个时，Array()才会返回由参数组成的新数组。
      参数只有一个正整数时，实际上是指定数组的长度。
      Array.of()基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。

    实例方法：copyWithin():
      在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。
      Array.prototype.copyWithin(target, start = 0, end = this.length)
        target（必需）：从该位置开始替换数据。如果为负值，表示倒数。
        start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。
        end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。

    实例方法：find() 和 findIndex():
      数组实例的find方法，用于找出第一个符合条件的数组成员。
        它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。
        如果没有符合条件的成员，则返回undefined。

      数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，
        如果所有成员都不符合条件，则返回-1。

      这两个方法都可以接受第二个参数，用来绑定回调函数的this对象
      这两个方法都可以发现NaN，弥补了数组的indexOf方法的不足

    实例方法：fill():
      fill方法使用给定值，填充一个数组。

    实例方法：entries()，keys() 和 values() :
      ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。
      它们都返回一个遍历器对象[Iterator]，可以用for...of循环进行遍历，
      唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。
      如果不使用for...of循环，可以手动调用遍历器对象的next方法，进行遍历。

    实例方法：includes():
      Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。
      该方法的第二个参数表示搜索的起始位置，默认为0。
        如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。
      indexOf方法有两个缺点，
        一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。
        二是，它内部使用严格相等运算符（===）进行判断，这会导致对NaN的误判。

      另外，Map 和 Set 数据结构有一个has方法，需要注意与includes区分。
        Map 结构的has方法，是用来查找键名的，
          比如Map.prototype.has(key)、WeakMap.prototype.has(key)、Reflect.has(target, propertyKey)。
        Set 结构的has方法，是用来查找值的，
          比如Set.prototype.has(value)、WeakSet.prototype.has(value)。

    实例方法：flat()，flatMap():
      flat()：
        该方法返回一个新数组，对原数据没有影响
        flat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1。
        如果原数组有空位，flat()方法会跳过空位（删除空位）。

      flatMap()只能展开一层数组。
        flatMap()方法的参数是一个遍历函数，该函数可以接受三个参数，分别是当前数组成员、当前数组成员的位置（从零开始）、原数组。
        flatMap()方法还可以有第二个参数，用来绑定遍历函数里面的this。

    实例方法：at():
      at()方法接受一个整数作为参数，返回参数指定位置的字符，支持负索引（即倒数的位置）。
      如果参数位置超出了字符串范围，at()返回undefined






