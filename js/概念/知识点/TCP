TCP:
  面向连接的、可靠的、基于字节流的传输层协议
UDP:
  面向无连接的传输层协议

比较：
  TCP的核心特性：
    1）面向连接
      连接：客户端和服务器之间的连接，在双方互相通信之前，TCP需要三次握手建立连接，
      UDP 不需要建立相应的连接过程
    2）可靠性
      可靠性体现在：有状态 并且可控制
      有状态：TCP会精准记录那些数据发送了，哪些数据被对方接收了，哪些没有被接收到，而且保证数据包按照有序到达，不允许半点出错
      可控制：当意识到丢包或者网络环境不佳时，TCP会根据具体情况调整自己的行为，控制自己的发送速度或者重发
      相应的 UDP是无状态的，不可控的
    3）面向字节流
       UDP的数据传输是基于数据报的，这是因为仅仅继承了IP层的特性
       TCP为了维护状态，将一个个IP包变成了字节流

TCP的三次握手的过程：（正常情况下：三次是最少的）
  客户端发送请求SYN、服务端接收请求并返回标志SYN和ACK、客户端带着标志(ACK)传给服务端 (客户端和服务端都是ESTABLISHED)
  状态：SYN-SENT  、       SYN-REVD            、       ESTABLISHED

为啥两次不行？>= 3次却可以？
  两次不行：无法确认客户端的接收能力
  eg: 网络传输丢包现象，就会发生重传


三次握手过程中可以携带数据么？
  第三次握手的时候，可以携带。前两次握手不能携带数据。
  如果前两次能够携带数据，那么一旦有人想攻击服务器，那么他只要在第一次握手中携带大量的数据，此时服务器
  势必会消耗更多的时间和内存空间去处理这些数据，这样会大大的增加服务器被攻击的风险


TCP的四次挥手：（服务端在发送ACK之后并不能立即返回FIN）
  客户端向服务端发送FIN，后客户端变成FIN-WAIT-1状态、
  服务端向客户端发送确认ACK，自己变成CLOSER-WAIT状态、
  客户端接受了服务端的确认后变更为FIN-WAIT2状态、
  之后服务端会向客户端发送FIN自己进入LAST-ACK状态，
  客户端收到FIN后，自己则变成TIME-WAIT然后发送ACK给服务端
  最后，客户端等待2个MSL后，没有收到服务端的请求则说明断开成功了。否则客户端会重新发送ACK请求

  MSL 报文最大生存时间（Maximum Segment Lifetime）

  等待2个MSL的意义？为啥不能是1个？
    1个MSL确保四次挥手中主动关闭房最后的ACK报文能够到达对象
    1个MSL确保对端没有收到ACK重传的FIN报文可以到达

  不等待会怎么样？
    如果不等待，客户端直接跑路，当服务端还有很多数据报要发给客户端，且还在路上的时候，
    若果客户端的端口此时被新的应用占用，那么新的应用就会收到无用的数据包，造成数据包混乱，
    所以最保险的做法就是等待完全断开后再启动新的应用

3次挥手为啥不行：
  三次挥手意味着服务端在收到客户端的FIN请求后需要将FIN和服务端的ACK同时传给客户端，
  但是事实上服务端需要先进行已有报文的传输，完成后才会传输FIN，这样就会造成延迟，在这个延迟过程中，
  客户端会误以为服务端没有收到FIN，从而不断地重发FIN

半连接队列：（SYN队列）
  当客户端发送SYN到服务端，服务端收到以后回复ACK和SYN，状态有LISTEN变成SYN_RCVD，此时这个连接就被推入了SYN队列

全连接队列：（ACCEPT队列）
  当客户端返回ACK，服务端接收后，三次握手完成，这个时候连接等待被具体的应用取走，
  在被取走之前，他会被推入另外一个TCP维护的队列，这个队列就是ACCEPT队列

SYN Flood 攻击原理：
   SYN Flood属于典型的DoS/DDoS攻击。
   原理：使用客户端在短时间内伪造大量不存在的IP地址，并向服务器疯狂发送SYN，
        对于服务端而言，会产生两个危险的后果：
        1）处理大量的SYN包并返回对应的ACK，势必有大量连接处于SYN_RCVD状态，从而沾满整个半连接队列，无法处理正常的请求
        2）由于是不存在的IP，服务端长时间收不到客户端的ACK，会导致服务端不断地重发数据，直至耗尽服务端的资源。

应对SYN Flood攻击：
  1）增加SYN连接，也就是增加SYN队列的容量
  2）减少SYN+ACK重试次数，避免大量的超时重发
  3）利用SYN Cookie技术，在服务端接收到SYN后不立即分配连接资源，而是根据这个SYN计算出一个Cookie，
     连同第二次握手回复给客户端，在客户端回复ACK的时候带上这个Cookie值，服务端验证Cookie合法之后才分配连接资源

TCP报文字段：
  1）源端口、目标端口：
     如何标识唯一标识一个连接？TCP连接四元组--源IP、源端口、目标IP、目标端口
     TCP报文怎么没有源IP和目标IP？这是因为在IP层就已经处理了IP。TCP只需要记录两者之间的端口就可以了。

  2）序列号
    指的是本报文段第一个字节的序列号。
    序列号是一个长为4字节，也就是32位的无符号整数，标识范围为0~2^32-1，如果达到最大值就循环到0
    序列号在TCP通信的过程中有两个作用：
    a）在SYN报文中交换彼此的初始序列号
    b）保证数据包按照正确的顺序组装

    ISN初始序列号，在三次握手的过程中，双方会用SYN报文来交换彼此的ISN
    ISN并不是一个固定的值，而是每4ms加一，溢出则回到0，这么做的原因是？
      ISN被攻击者预测到，要知道源IP和源端口号都是很容易伪造的，
      当攻击者猜测到ISN之后直接就可以伪造一个RST，就可以强制连接关闭的。
      而动态增长的ISN大大提高了猜测ISN难度。


  3）确认号（ACK）
    用来告知对方下一个期望接收的序列号，小于ACK的所有字节已经收到了

  4）标记位
    常见的标记位有SYN、ACK、FIN、RST、PSH
    FIN即finish，表示发送方准备断开连接
    RST即reset，用来强制断开连接
    PSH即push，告知对方这些数据包收到后应该马上交给上层的应用不能缓存

  5）窗口大小
    占用两个字节，也就是16位，但实际上是不够用的，因此TCP引入了窗口缩放的选项，作为窗口缩放的比例因子，
    这个比例因子的范围是0~14，比例因子可以将窗口的值扩大为原来的2^n

  6）校验和
    占用两个字节，防止传输过程中，数据包邮损害，如果遇到校验和由差错的报文，TCP直接丢弃之，等待重传

  7）可选项
    ———————————————————————————————— |————————————————————————————————|————————————————————————————————
            种类（Kind）1byte                 长度（Length）1byte                       值（value）
    ———————————————————————————————— |————————————————————————————————|————————————————————————————————
    常用的可选项：
      a）TimeStamp:TCP时间戳
      b）MSS：指的是TCP允许的从对方接收的最大报文段
      c）SACK：选择确认选项
      d）Window Scale：窗口缩放选项

TCP快速打开的原理（TFO）：TCP三次握手优化
  1）TFO流程：
    a）首轮三次握手
      首先客户端发送SYN给服务端，服务端收到后
      此时不是立刻回复SYN+ACK，而是通过计算得道一个SYN cookie，将这个Cookie放到TCP报文的Fast Open 选项中，然后才给客户端返回
      客户端会将这个Cookie值缓存下来。完成后续握手
    b）后面的三次握手
      在后面的三次握手中，客户端会将之前缓存的cookie、SYN和HTTP请求发送给服务端，服务端验证了Cookie的合法性，就可以返回HTTP响应了
      当然正常的，客户端ACK还是要正常的传输过来的，不然怎么叫三次握手呢。

  2）TFO的优势：
    TFO的优势并不在于首轮三次握手，而是后面的握手，在拿到客户端的cookie并验证通过之后，可以直接返回HTTP响应，充分利用了一个RTT（往返时延）的时间
    提前进行数据传输，积累起来就是一个比较大的优势

TCP报文中的时间戳TimeStamp的作用：
  1）计算往返时延（RTT）
  2）防止序列号的回绕问题

TCP的超时重传时间计算：TODO
  TCP具有超时重传机制，即间隔一段时间没有等到数据包的回复时，重传这个数据包。


TCP的流量控制：

