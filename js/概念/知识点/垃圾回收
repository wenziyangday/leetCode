垃圾回收：
  在JavaScript中 拥有自动回收垃圾机制的，通过一定的算法，找出不在使用或者引用的变量或者属性，在固定的时间间隔周期内释放其所占用的内存。

  垃圾产生：
    当一个对象没有任何的变量或属性对它进行引用，此时我们将永远无法操作该对象，
    这种对象就是一个垃圾，这种对象过多会占用大量的内存空间，导致程序变慢。

    只需要的是将不再使用的对象设置为null即可

  栈内存回收：
    自动回收

  堆内存回收：
    v8内存限制：
      64位系统1.4G、32位系统0.7G

    不能进行无上限的内存分配：
      单线程的执行机制
      js垃圾回收机制

  引用计数垃圾收集：
     当对象没有其他对象引用（零引用）时 (对象的引用为null 也就是 a = null)，进行对象释放（垃圾回收机制回收）
     操作步骤：
       1）跟踪记录每个变量值被使用的次数
       2）当声明一个变量并且将一个引用类型数据赋值给这个变量的时候，这个引用类型数据的引用次数就标记为 1
       3）如果当这个引用类型数据又赋值给另一个变量，那么引用次数就+1
       4）如果变量被其他的值覆盖，则引用次数-1
       5）当这个引用类型数据的引用次数变为0的时候,这个变量就没有被使用了，也无法访问，垃圾回收器就会在执行时，销毁引用次数为0的引用类型数据，回收其所占用的内存空间。
     问题：
      对于对象中出现循环引用时，则无法释放。
        解决办法：
          在引用结束后，手动将其设置为null

      优点：
        引用计数为零时，发现垃圾立即回收
        最大限度减少程序暂停

      缺点：
        无法回收循环引用的对象
        空间开销比较大


  标记-清除算法：
    关键：对象是否可以获得
    描述：
      假定设置一个叫做根的对象（全局对象）。垃圾回收器将 定期 从根开始，找所有从根开始引用的对象
      然后找这些对象的引用对象，从根开始，。。。。，垃圾回收器将找到所有可以获得的对象，和收集所有不能获得的对象

    核心：
      先进行标记，然后在进行清除

    操作步骤：
      1）垃圾收集器在运行时会给内存中所有的变量都加上一个标记，假设内存中所有的对象全部是垃圾，全部标记为0
      2）然后从各个根对象开始遍历，把不是垃圾的节点改成1
      3）清理所有标记为0的垃圾，销毁并回收它们所占用的内存空间
      4）最后把所有内存中对象标记修改为0，等待下一轮的垃圾回收

    限制：
      那些无法从根对象查询到的对象都将被清除

    优点：
      实现简单，标记情况无非是打与不打的两种情况，通过二进制（0和1）就可以为其标记。
      能够回收循环引用的对象
      是v8引擎使用最多的算法

    缺点：
      在清除垃圾之后，剩余对象的内存位置是不变的，就会导致空闲内存空间不连续。这样就出现了内存碎片，并且由于剩余空间不是整块，就需要内存分配的问题。


  标记整理算法：为了解决标记清除所带来的内存不连续的问题
    在标记结束后标记整理算法会将不需要清理的对象向内存一端移动，最后清理边界的内存。

  V8引擎的垃圾回收：
    1）V8引擎的垃圾回收采用标记清除法与分代回收法
    2）分为新生代和老生代

    针对不同对象采用不同算法：
      （1）新生代：对象的存活时间较短。新生对象或只经过一次垃圾回收的对象。
        新生代内存结构：


        回收：
          回收新生代对象主要采用复制算法（Scavenge 算法）加标记整理算法。而Scavenge 算法的具体实现，主要采用了Cheney算法。

        tips:
          一轮GC还存活的新生代需要晋升(变成老生代)。

      （2）老生代：对象存活时间较长。经历过一次或多次垃圾回收的对象。

        回收：
          回收老生代对象主要采用标记清除、标记整理、增量标记算法，主要使用标记清除算法，只有在内存分配不足时，采用标记整理算法。

          1）首先使用标记清除完成垃圾空间的回收；
          2）采用标记整理进行空间优化；
          3）采用增量标记进行效率优化；

