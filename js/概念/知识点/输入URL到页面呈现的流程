网络层面：
  1）构建请求
  2）查找强缓存
  3）DNS解析：就是域名和IP的一一映射过程
  4）建立TCP连接 （TCP连接的三个阶段，建立和服务器之间的通信）
    a）通过三次握手（总共发送3个数据包确认已经建立连接）建立客户端和服务器之间的连接
    b）进行数据传输
      过程：
        A）接收方接收到数据包后必须要向发送方确认，如果发送方没有接到这个确认消息，就判定数据包丢失，并重新发送该数据包。
        B）传输优化策略：将大的数据包拆成一个个小包，依次传输到接收方，接收方按照这个小包的顺序把他们组装成完整的数据包。
    c）断开连接的阶段。数据传输完成后，需要断开连接了，通过四次挥手来断开连接。

    TCP的可靠性体现在：
      a）三次握手确认连接
      b）数据包校验保证数据到达接收方
      3）四次挥手断开连接。
  5）发送HTTP请求
    HTTP请求组成：
      a）请求行：
      b）请求头
      c）请求体
  6）网络响应
    HTTP响应组成：
      a）响应行：由HTTP协议版本、状态码和状态描述组成
      b）响应头
      c）响应体


解析算法（页面构建）：
  1）构建DOM树 （DOM树）
    a）语法分析
    b）词法分析

  2）样式计算 （样式来源：外部样式文件（link）、内部样式（style）、行内样式）（DOM样式）
    a）格式化样式表：将以上三种样式来源转化为一个结构化的对象即styleSheets
    b）标准化样式属性：em -> px、red -> #ff0000、bold -> 700 形如这样的转化
    c）计算每个节点的具体样式：
      规则：
        A）继承：子元素继承父级元素的样式属性
        B）层叠：最终的样式取决于各个属性共同作用的效果

  3）生成布局树
    布局树：将生成的DOM树和DOM样式，通过浏览器的布局系统确定元素的位置从而生成一颗布局树
    布局树生成的大致过程：
      a）遍历生成的DOM树节点，并把他们添加到布局树中
      b）计算布局树节点的坐标位置

    注意：布局树中是不会包含head标签和display: none的元素。


渲染过程：
  1）建立图层树
    原因：
      a）3d动画如何呈现出变换效果
      b）层叠元素如何控制显示和隐藏
      因此在浏览器构建玩布局树之后还要对特定节点进行分层，构建一棵图层树
    合成层：
      节点的图层会默认属于父节点的图层
      a）显示合成
        A）拥有层叠上下文的节点
          (1) HTML根元素本身就具有层叠上下文
          (2) 普通元素设置position不是static且设置了z-index属性，就会产生层叠上下文
          (3) 元素的opacity值不是1
          (4) 元素的transform值不是none
          (5) 元素的filter值不是none
          (6) 元素的isolation值是isolate
          (7) will-change指定的属性值为上面任意一个
        B）需要裁剪的地方
          超出容器的部分是会被裁剪的
      b）隐式合成
        概念：
          层叠等级低的节点被提升为但单独的图层之后，那么所有层叠等级比它高的节点的都会成为一个单独的图层
          隐式合成风险（层爆炸原理）：
            在一个大型应用中，当一个z-index比较低的元素被提升为单独图层后，层叠在他上面得到元素都会被提升为一个单独图层，可能会增加上千个图层，大大增加内存的压力，甚至直接
            让页面崩溃。

  2）生成绘制列表
    渲染引擎将图层的绘制拆分成一个个绘制指令，比如先画背景、再描绘边框。。。然后将这些指令按照顺讯组合成一个绘制列表
  3）生成图块并栅格化
    通过合成线程将图层进行分块。这些图层块通常大概有256 * 256 或者 512 * 512这个规格，因此可以大大加快首屏加载速度。
  4）显示器显示内容


  流程：
    建立图层树 -> 生成绘制列表 -> 通过合成线程 -> 生成图块 -> 绘制视口附近图块 -> 首次合成优化 -> 图块栅格化 -> 生成位图数据 -> 浏览器进程绘制 -> 发送到显卡 -> 显示器显示

