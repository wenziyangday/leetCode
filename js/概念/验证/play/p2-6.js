{
  /**
   * ssr：
   *  解决了以下两种问题
   *    SEO：搜索引擎优先爬取页面HTML结构，使用ssr时，服务端已经生成了和业务相关联的html，有利于seo
   *    首屏呈现渲染：用户无需等待页面所有js加载完成就可以看到页面视图（压力来到了服务器，所以需要权衡哪些用服务段渲染，哪些交给客户端）
   *
   *    缺点：
   *      复杂度：整个项目的复杂度
   *      库的支持性，代码兼容
   *      性能问题：
   *        每个请求都会有n个实例创建，不然会污染，消耗会变得很大
   *        缓存node serve、Nginx判断当前用户有没有过期，如果没过期就缓存，用刚刚的结果
   *        降级：监控cpu、内存占用过多，就spa 返回单个的壳
   *      服务器负载变大，相对于前后端分离 服务器只需提供静态资源来说，ssr服务器负载更大，所以慎重使用
   *
   *    选择ssr：
   *      1.需要SEO的页面是否只是少数几个，这些是否可以使用预渲染（Prerender SPA Plugin）实现
   *      2.首屏的请求响应逻辑是否复杂，数据返回是否大量且缓慢
   *
   *    使用ssr不存在单例模式，每次用户请求都会创建一个新的vue实例
   *    使用ssr需要实现服务端首屏渲染和客户端激活
   *    服务端异步获取数据asyncData可以分为首屏异步获取和切换组件获取
   *      1.首屏异步获取数据，在服务端预渲染的时候应该就已经完成
   *      2.切换组件通过mixin混入，在beforeMount钩子完成数据获取
   * */
}

{
  /**
   * 作用域链：
   *  一般情况下，变量取值到 创建 这个变量 的函数的作用域中取值。
   *  但是如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。
   *
   *  作用域：
   *    全局作用域
   *    函数作用域
   * */

  const a = 100;

  function f() {
    const a = 1000

    function f1() {
      console.log(a);
    }
  }
}

{
  function isObj(x, y) {
    if (x === y) {
      return x !== 0 || y !== 0 || 1 / x === 1 / y;
    } else {
      return x !== x && y !== y;
    }
  }
}

{
  /**
   * instanceof 基本数据类型
   * */

  class PrimitiveNumber {
    static [Symbol.hasInstance](x) {
      return typeof x === 'number';
    }
  }

  console.log(11 instanceof PrimitiveNumber)
}

{
  /**
   * typeof 正确判断数据类型
   *  对于原始数据类型 除了null 都可以准确反应数据类型
   *  但对于引用类型 除了函数以外，都会显示Object 此时通常使用instanceof
   * */
}

{
  /**
   * BigInt：
   *  一种新型的数据类型，用于当整数数值大于Number数据类型支持的范围时。这种数据类型允许我们安全地对大整数执行算术操作，表示高分辨率的时间戳，使用
   *  大整数id等等，而不需要使用库
   * */
}

{
  /**
   * 0.1 + 0.2 !== 0.3 ?
   * 原因：
   *  0.1 和 0.2 在转换成二进制后会无限循环，由于标准位数的限制 后面多余的位数会被截掉，此时会出现了精度的损失，
   *  相加后浮点数小数位的限制 而阶段的二进制数字在转换为十进制就会变成 0.3000000000004
   * */
}

{
  /**
   * null 不是对象
   * 虽然 typeof null 会输出object，但是这只是js存在的一个bug
   * */
}

{
  /**
   * 内存泄漏：
   *  程序中已动态分配的堆内存由于某种原因未被释放或无法释放
   *
   *    1.根据js的垃圾回收机制，当内存中引用的次数为0的时候内存才会被回收
   *    2.全局执行上下文中的对象被标记位不在使用才会被释放
   *
   *    内存泄漏场景：
   *      全局变量过多。通常是变量未被定义或者胡乱引用了全局变量
   *      闭包。未手动解决闭包遗留的内存引用。定义了闭包就要消除闭包带来的副作用。
   *      事件监听未被移除
   *      缓存，建议所有缓存都设置好过期时间
   * */
}

{
  /**
   * webSocket 如何兼容低版本浏览器
   *  Adobe flash socket
   *  activeX HTMLFile（IE）
   *  基于multipart编码发送xhr
   *  长轮询的xhr
   * */
}

{
  /**
   * vue3 的tree shaking 带来的优势：
   *  减少程序体积（更小）
   *  减少程序执行时间（更快）
   *  便于将来对程序架构进行优化（更友好）
   * */
}

{
  /**
   * TODO
   *
   *  composition 可以说是vue3的最大特点，为什么要引入呢
   *  通常vue2开发的项目普遍会存在以下问题：
   *    代码的可读性随着组件变大而变差
   *    每一种代码复用的方式，都存在缺点
   *    typescript 支持优先
   *
   *  优势：
   *    在逻辑组织和逻辑复用方面，composition api 是优于 option api
   *    因为composition api 几乎是函数，会有更好的类型推断
   *    composition api 对tree-shaking 友好，代码也更容易压缩
   *    composition api中见不到this的使用，减少了this指向不明的情况
   *    如果是小型组件，可以继续使用 option api 也是十分友好的
   *
   * */
}

{
  /**
   * vue3的性能提升
   *  编译阶段
   *    优化了以下几个方面：
   *      1.diff算法优化
   *        增加了静态标记（为会发生变化的地方添加一个flag，下次繁盛变化的时候直接找到该地方进行比较）
   *      2.静态提升
   *        vue3 中对不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接复用，避免了重复创建节点，大型应用会获得收益，避免重复创建，优化了
   *        运行时的内存占用
   *      3.事件监听缓存
   *        默认情况下绑定事件行为会被视为动态绑定，所以每次都会去追踪他的变化
   *      4.SSR优化
   *        当静态内容大到一定量级时候，会用createStaticVNode方法在客户端生成一个static node 这些静态node 会被直接innerHtml，就不需要
   *        创建对象，然后根据对象渲染
   *  源码体积
   *    移除了一些不常用的api，再者通过tree shaking减小包体积
   *    任何一个函数，如ref、reactived、computed等 仅在用到的时候才打包，没用的模块都会被摇掉，打包的整体体积变小
   *
   *  响应式系统：
   *    vue2 采用的是defineProperty来劫持整个对象，然后进行深度的遍历所有的属性，给每个属性添加getter 和 setter，实现响应式
   *    vue3 采用的是proxy重写了响应式系统，因为可以对整个对象监听，所以不需要深度遍历
   *      1.可以监听动态属性的添加
   *      2.可以监听到数组的索引和length属性
   *      3.可以监听删除属性
   * */
}

{
  /**
   * web中常见的攻击方式：
   *  web 攻击是针对用户上网行为或者网站服务器等设备进行攻击的行为
   *  如植入恶意代码，修改网站权限，获取网站用户隐私信息等等
   *
   *  常见的有 xss、csrf、sql注入
   * */
}

{
  /**
   *  TODO
   *  大文件的断点重传
   * */
}
